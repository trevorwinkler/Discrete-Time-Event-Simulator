/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package pa2;

import java.util.PriorityQueue;
import java.util.Random;
import java.util.LinkedList;


class Process {
    static int nextId = 1;
    int id;
    double arrivalTime;
    double serviceTime; // Time for CPU or Disk

    public Process(double arrivalTime, double serviceTime) {
        this.id = nextId++;
        this.arrivalTime = arrivalTime;
        this.serviceTime = serviceTime;
    }
}


enum EventType {
    PROCESS_ARRIVAL, PROCESS_COMPLETED, DISK_COMPLETED
}

class Event implements Comparable<Event> {
    double time;
    EventType type;
    Process process;

    public Event(double time, EventType type, Process process) {
        this.time = time;
        this.type = type;
        this.process = process;
    }

    @Override
    public int compareTo(Event other) {
        return Double.compare(this.time, other.time);
    }
}

class EventQueue {
    private PriorityQueue<Event> queue = new PriorityQueue<>();

    public void addEvent(Event e) {
        queue.add(e);
    }

    public Event getNextEvent() {
        return queue.poll();
    }

    public boolean isEmpty() {
        return queue.isEmpty();
    }
}





class App {
    double lambda; // Arrival rate
    double avgCpuServiceTime;
    double avgDiskServiceTime;
    EventQueue eventQueue = new EventQueue();
    LinkedList<Process> cpuQueue = new LinkedList<>();
    LinkedList<Process> diskQueue = new LinkedList<>();
    boolean cpuBusy = false;
    boolean diskBusy = false;

    // Metrics
    double totalTime = 0;
    double totalTurnaroundTime = 0;
    int completedProcesses = 0;
    double totalCpuBusyTime = 0;
    double totalDiskBusyTime = 0;
    double lastEventTime = 0;
    int totalCpuQueueLength = 0;
    int totalDiskQueueLength = 0;
    int cpuQueueEvents = 0;
    int diskQueueEvents = 0;

    Random random = new Random();

    public App(double lambda, double avgCpuServiceTime /*double avgDiskServiceTime*/) {
        this.lambda = lambda;
        this.avgCpuServiceTime = avgCpuServiceTime;
        //this.avgDiskServiceTime = avgDiskServiceTime;
    }

    private double getNextArrivalTime() {
        return Math.log(1-random.nextDouble())/(-lambda);
    }

    private double getServiceTime(double average) {
        return Math.log(1-random.nextDouble())/(-1/average);
    }

    public void run() {
        double currentTime = 0;
        
        eventQueue.addEvent(new Event(currentTime + getNextArrivalTime(), EventType.PROCESS_ARRIVAL, null));

        while (completedProcesses < 10000) {
            Event event = eventQueue.getNextEvent();
            currentTime = event.time;
            updateQueueLengths(currentTime);

            switch (event.type) {
                case PROCESS_ARRIVAL:
                    Process arrivingProcess = new Process(currentTime, getServiceTime(avgCpuServiceTime));
                    if (!cpuBusy) {
                        cpuBusy = true;
                        double completionTime = currentTime + arrivingProcess.serviceTime;
                        totalCpuBusyTime += arrivingProcess.serviceTime;
                        eventQueue.addEvent(new Event(completionTime, EventType.PROCESS_COMPLETED, arrivingProcess));
                    } else {
                        cpuQueue.add(arrivingProcess);
                    }
                    
                    eventQueue.addEvent(new Event(currentTime + getNextArrivalTime(), EventType.PROCESS_ARRIVAL, null));
                    break;
                case PROCESS_COMPLETED:
                    if (!cpuQueue.isEmpty()) {
                        Process nextProcess = cpuQueue.poll();
                        double completionTime = currentTime + nextProcess.serviceTime;
                        totalCpuBusyTime += nextProcess.serviceTime;
                        eventQueue.addEvent(new Event(completionTime, EventType.PROCESS_COMPLETED, nextProcess));
                    } else {
                        cpuBusy = false;
                    }
                    if (random.nextDouble() > 0.6) {
                        if (!diskBusy) {
                            diskBusy = true;
                            double diskServiceTime = getServiceTime(avgDiskServiceTime);
                            totalDiskBusyTime += diskServiceTime;
                            eventQueue.addEvent(new Event(currentTime + diskServiceTime, EventType.DISK_COMPLETED, event.process));
                        } else {
                            diskQueue.add(event.process);
                        }
                    } else {
                        completedProcesses++;
                        totalTurnaroundTime += (currentTime - event.process.arrivalTime);
                    }
                    break;
                case DISK_COMPLETED:
                    if (!diskQueue.isEmpty()) {
                        Process nextProcess = diskQueue.poll();
                        double diskCompletionTime = currentTime + getServiceTime(avgDiskServiceTime);
                        totalDiskBusyTime += getServiceTime(avgDiskServiceTime);
                        eventQueue.addEvent(new Event(diskCompletionTime, EventType.DISK_COMPLETED, nextProcess));
                    } else {
                        diskBusy = false;
                    }
                    
                    if (!cpuBusy) {
                        cpuBusy = true;
                        double cpuServiceTime = getServiceTime(avgCpuServiceTime);
                        totalCpuBusyTime += cpuServiceTime;
                        eventQueue.addEvent(new Event(currentTime + cpuServiceTime, EventType.PROCESS_COMPLETED, event.process));
                    } else {
                        cpuQueue.add(event.process);
                    }
                    break;
            }
            lastEventTime = currentTime;
        }
        printMetrics();
    }

    private void updateQueueLengths(double currentTime) {
        totalCpuQueueLength += cpuQueue.size() * (currentTime - lastEventTime);
        totalDiskQueueLength += diskQueue.size() * (currentTime - lastEventTime);
        if (!cpuQueue.isEmpty()) cpuQueueEvents++;
        if (!diskQueue.isEmpty()) diskQueueEvents++;
    }

    private void printMetrics() {
        double averageTurnaroundTime = totalTurnaroundTime / completedProcesses;
        double averageThroughput = completedProcesses / lastEventTime;
        double averageCpuUtilization = totalCpuBusyTime / lastEventTime;
        //double averageDiskUtilization = totalDiskBusyTime / lastEventTime;
        double averageCpuQueueLength = totalCpuQueueLength / lastEventTime;
        //double averageDiskQueueLength = totalDiskQueueLength / lastEventTime;

        System.out.println("-----------------------------------------");
        System.out.println("Average Turnaround Time: " + averageTurnaroundTime);
        System.out.println("Average Throughput: " + averageThroughput); 
        System.out.println("CPU Utilization: " + averageCpuUtilization); 
        //System.out.println("Disk Utilization: " + averageDiskUtilization); 
        System.out.println("Average Number of Processes in Cpu Queue: " + averageCpuQueueLength); 
        //System.out.println("Average Number of Processes in Disk Queue " + averageDiskQueueLength); 
        System.out.println("-----------------------------------------");
    }
    
        public static void main(String[] args) {
            if (args.length != 2) {
                System.out.println("Usage: java Main <lambda> <avg CPU service time> <avg Disk service time>");
                System.exit(1);
            }
    
            double lambda = Double.parseDouble(args[0]);
            double avgCpuServiceTime = Double.parseDouble(args[1]);
            //double avgDiskServiceTime = Double.parseDouble(args[2]);
    
            App simulator = new App(lambda, avgCpuServiceTime /*avgDiskServiceTime*/);
            simulator.run();
        }
    }

